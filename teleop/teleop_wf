#pragma config(Sensor, S1,     ,               sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "5619Drive.h"

//******************************Global Constants**********************************
/*The threshold variable is the "dead head" for inconsistencies in the joystick*/
const int Threshold = 15;
//The spin of the robot in Omni mode will always be at the same speed since it uses
//the shoulder buttons and not the analog
//spin during tank drive is handled differently by the y values of the analog.
const int SpinSpeed = 25;
//Turn on logging
const bool DEBUG = true;
//This value can be changed by the "start" button to switch between
//tank and omni drive. Not sure why we want it, but there it is
bool OMNI=true;

// global values to catch the values of the analog joysticks
//renamed so that the code is more readible
int rightJoystickX;
int rightJoystickY;
int leftJoystickX;
int leftJoystickY;
//******************************End of Global Constants*****************************

//******************************Joystick setup Functions****************************
//This function will reset the input value to zero if it is within the deadhead threshold;
//Threshold is a global value
int setDeadHead(int coordinateValue){
	if (abs(coordinateValue)<Threshold){
		return 0;}
	else {
		return coordinateValue;}
}

//Takes the values from the joystick and make appropriate mappings
void updateJoystick() {
	//All of these are divided by 128 and then multiplied by 100
	//This will create a proportional value between -100 and 100 which can then
	// be used as power to the motors

	// X value of right joystick from -128 to 127
	rightJoystickX = 100*joystick.joy1_x2/128;
	// Y value of right joystick from -128 to 127
	rightJoystickY = 100*joystick.joy1_y2/128;
	// X and Y joystick value from 128 to 127
	leftJoystickY = 100*joystick.joy1_y1/128;
	leftJoystickX = 100*joystick.joy1_x2/128;

	//We are going to handle the dead head functionality in order to clean up the later
	// code. So we will set joystick values to zero if they are within the deadhead zone
	rightJoystickX=setDeadHead(rightJoystickX);
	rightJoystickY=setDeadHead(rightJoystickY);
	leftJoystickX=setDeadHead(leftJoystickX);
	leftJoystickY=setDeadHead(leftJoystickY);
}
//********************************End joystick setup functions*****************

//*****************Wrapper functions for drive functionality******************
void spinLeft(){
	if (DEBUG){
		writeDebugStreamLine("In spinLeft");
	}
	Drive_spinLeft(SpinSpeed);
}

void spinRight() {
	if (DEBUG){
		writeDebugStreamLine("In spinRight");
	}
	Drive_spinRight(SpinSpeed);
}

void allStop(){
	if (DEBUG){
		writeDebugStreamLine("In allStop");
	}
	Drive_allStop();
}
//********************End Wrapper functions***************************

//Left analog control will drive the Omni Drive (with the center wheel)
void leftOMNIAnalogControl() {
	int centerPowerLevel=0;  //Good programming, we initialize it to a value
	float controllerAngleRad=0;  // Need initialization here

	//This if-else will catch the divide by zero problem
	if (leftJoystickX==0){
		centerPowerLevel=0;
	}
	else {
		//No need to convert to convert to degrees since the cos below
		//takes a radian value I THINK    TEST TEST
		controllerAngleRad=atan(leftJoystickY/leftJoystickX);  //In radians
		if (DEBUG){
			writeDebugStreamLine("Controller Angle: %d", controllerAngleRad);
		}
			//This calculation needs more documentation.  More to come.
			/*
			I believe that atan gives values from -PI to PI
			1) We want the centerPowerLevel (CPL) at 100 at angle=0 radians [right]
			2) We want the CPL at 0 when angle=pi/2 (90 degrees) [straight]
			3) We want the CPL at -100 when angle=pi (180 degree) [left]
			4) We want the CPL at 0 when angle=-pi/2 (270 degrees) [backward]
			This coincides with a cos function with an amplitude of 100

			QUESTION: Is the positive value for the center wheel left or right?
			ASSUMPTION: Positive = right
			If the assumption is wrong we need to make the function
			round( -100*cos(controllerAngleRad))  [I think]  TEST TEST TEST!!
			*/
			centerPowerLevel = round( 100*cos(controllerAngleRad));
		}
		if (DEBUG){
			writeDebugStreamLine("In leftAnalogControl");
			writeDebugStreamLine("centerPowerIs: %d",centerPowerLevel ); //TEST!!!
			writeDebugStreamLine("controllerAngleRad: %d", controllerAngleRad);
		}
		Drive_driveOmni(leftJoystickY,centerPowerLevel);
	}

	//Only used when OMNI=false set by the "start" button
	// Tank drive ignores the x value of the analog controller (Should this be the case?)
	void tankAnalogControl() {
		if (DEBUG){
			writeDebugStreamLine("In tankAnalogControl");
		}
		Drive_turn(leftJoystickY,leftJoystickX);
	}
	//********************************************************************************
	//********************************************************************************
	/*
	These are the drive controls
	1) driver controls
	2) operator controls
	*/
	void driveJoyStickControl(){
		//This set of if statements handle the different button functions.
		// Question to test.  Should the statements be mutually exclusive
		// Should we only handle one input per cycle?  Results could be strange TEST
		// I will write it to give priority to certain functions
		// buttons come before analog joysticks

		// If any of the letter buttons are pressed, register this as an all stop
		if (joy1Btn(1) || joy1Btn(2) || joy1Btn(3) || joy1Btn(4)){
			allStop();
		}
		// Top left shoulder button will spin the robot left
		if (joy1Btn(5)){
			spinLeft();
		}
		// Top right shoulder botton will spin the robot right
		if (joy1Btn(6)){
			spinRight();
		}
		//Bottom left shoulder do nothing placeholder
		if (joy1Btn(7)){
		}
		//Bottom right shoulder do nothing placeholder
		if (joy1Btn(8)){
		}
		//back button do nothing placeholder
		if (joy1Btn(9)){
		}
		//start button switch between tank and OmniDrive
		//Note: OMNI=false, this will remove any use of the center wheel
		if (joy1Btn(10)){
			//if we are switching OFF Omni play Beep Beep
			if (OMNI){
				PlaySound(soundBeepBeep);
			}
			//If we are switching back to Omni Beep Beep Beep Beep
			else {
				PlaySound(soundBeepBeep);
				PlaySound(soundBeepBeep);
			}
			OMNI=!OMNI;
		}

		if (OMNI){
			//Left analog button will manage the omnidrive and
			//move the robot at the angle given on the analog pad
			leftOMNIAnalogControl();
		}
		else {
			//Right analog will run the robot like a tank drive not using the center wheel
			tankAnalogControl();
		}

	}

	void operatorJoystickControl(){
		//This set of if statements handle the different button functions.
		// Question to test.  Should the statements be mutually exclusive
		// Should we only handle one input per cycle?  Results could be strange TEST

		// If any of the letter buttons are pressed
		//turn on the conveyor
		//TO BE DONE: Some set should reverse the conveyor
		if (joy1Btn(1) || joy1Btn(2) || joy1Btn(3) || joy1Btn(4)){
			//To be done
		}
		// Upper left shoulder button Raise conveyor
		if (joy1Btn(5)){
			//raise conveyor
		}
		// Upper right shoulder button
		if (joy1Btn(6)){
			//nothing
		}
		//Bottom left shoulder do nothing placeholder
		if (joy1Btn(7)){
			//lower conveyor
		}
		//Bottom right shoulder release bucket
		if (joy1Btn(8)){
			//bucket release
		}
		//back button do nothing placeholder
		if (joy1Btn(9)){
		}
		//do nothing placeholder
		//Maybe reset encoders????
		if (joy1Btn(10)){
			//reset encoders
		}

		//Missing any analog controls
	}
	//************************************End Driver/Operator Functions*******************************
	//************************************************************************************************

	task main()
	{

		waitForStart();

		while(true)
		{
			// state machine loop
			getJoystickSettings(joystick);
			driveJoyStickControl();
			//operatorJoystickControl();

		}

	}
